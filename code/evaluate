#!/usr/bin/env bash

# Exit after the first error. This way, a keyboard interrupt for one verifier
# process will prevent others from running as well.
set -e

TEST_CASES_DIR="../test_cases"

CORRECT_COLOUR=046 # green
UNSOUND_COLOUR=196 # red
IMPRECISE_COLOUR=214 # orange-ish yellow
INVALID_COLOUR=244 # grey

# Arg 1 is the colour code, and arg 2 is the text to be coloured
# Taken from: https://stackoverflow.com/a/69648792/7905483
colourise () { echo -ne "\e[38;5;${1}m${2}\e[0m"; }

max_score=0 # total number of verified examples
verified=0 # true positives
unverified=0 # true negatives
unsound=0 # false positives
imprecise=0 # false negatives

while IFS=, read net spec expected; do
    echo -n "$net @ $spec: "
    prediction=$( \
        python verifier.py \
        --net $net \
        --spec "$TEST_CASES_DIR/$net/$spec" \
    )

    if [[ "$prediction" == $expected ]]; then
        colour=$CORRECT_COLOUR
        if [[ $expected == verified ]]; then
            ((verified+=1))
        else
            ((unverified+=1))
        fi
    elif [[ "$prediction" == verified ]]; then
        colour=$UNSOUND_COLOUR
        ((unsound+=1))
    elif [[ "$prediction" == 'not verified' ]]; then
        colour=$IMPRECISE_COLOUR
        ((imprecise+=1))
    else
        colourise $INVALID_COLOUR "$prediction"
        echo
        exit 1
    fi

    if [[ $expected == verified ]]; then
        ((max_score+=1))
    fi

    colourise $colour "$prediction"
    echo
done < "$TEST_CASES_DIR/gt.txt"

cat << EOS

=======
Summary
=======

Total: $((verified + unverified + unsound + imprecise))
Correct: $(colourise $CORRECT_COLOUR $((verified + unverified)))
Unsound: $(colourise $UNSOUND_COLOUR $unsound)
Imprecise: $(colourise $IMPRECISE_COLOUR $imprecise)

Score: $((verified - 2 * unsound))/$max_score
EOS
